import java.io.*;
import java.util.*; 

		class ColEdge
			{
			int u;
			int v;
			}
			
			 class customArray{
                int breakIndex;
    int number;
   

    public customArray(int breakpoint,int n){
        breakIndex = breakpoint;
        number = n;
    }
    @Override
    public String toString(){
    	return breakIndex +"," + number;
    }
}
		
public class ReadGraph
		{
		
		public final static boolean DEBUG = true;
		
		public final static String COMMENT = "//";
		
		public static void main( String args[] )
			{
			if( args.length < 1 )
				{
				System.out.println("Error! No filename specified.");
				System.exit(0);
				}

				
			String inputfile = args[0];
			
			boolean seen[] = null;
			
			//! n is the number of vertices in the graph
			int n = -1;
			
			//! m is the number of edges in the graph
			int m = -1;
			
			//! e will contain the edges of the graph
			ColEdge e[] = null;
			
			try 	{ 
			    	FileReader fr = new FileReader(inputfile);
			        BufferedReader br = new BufferedReader(fr);

			        String record = new String();
					
					//! THe first few lines of the file are allowed to be comments, staring with a // symbol.
					//! These comments are only allowed at the top of the file.
					
					//! -----------------------------------------
			        while ((record = br.readLine()) != null)
						{
						if( record.startsWith("//") ) continue;
						break; // Saw a line that did not start with a comment -- time to start reading the data in!
						}
	
					if( record.startsWith("VERTICES = ") )
						{
						n = Integer.parseInt( record.substring(11) );					
						if(DEBUG) System.out.println(COMMENT + " Number of vertices = "+n);
						}

					seen = new boolean[n+1];	
						
					record = br.readLine();
					
					if( record.startsWith("EDGES = ") )
						{
						m = Integer.parseInt( record.substring(8) );					
						if(DEBUG) System.out.println(COMMENT + " Expected number of edges = "+m);
						}

					e = new ColEdge[m];	
												
					for( int d=0; d<m; d++)
						{
						if(DEBUG) System.out.println(COMMENT + " Reading edge "+(d+1));
						record = br.readLine();
						String data[] = record.split(" ");
						if( data.length != 2 )
								{
								System.out.println("Error! Malformed edge line: "+record);
								System.exit(0);
								}
						e[d] = new ColEdge();
						
						e[d].u = Integer.parseInt(data[0]);
						e[d].v = Integer.parseInt(data[1]);

						seen[ e[d].u ] = true;
						seen[ e[d].v ] = true;
						
						if(DEBUG) System.out.println(COMMENT + " Edge: "+ e[d].u +" "+e[d].v);
				
						}
									
					String surplus = br.readLine();
					if( surplus != null )
						{
						if( surplus.length() >= 2 ) if(DEBUG) System.out.println(COMMENT + " Warning: there appeared to be data in your file after the last edge: '"+surplus+"'");						
						}
					
					}
			catch (IOException ex)
				{ 
		        // catch possible io errors from readLine()
			    System.out.println("Error! Problem reading file "+inputfile);
				System.exit(0);
				}

			for( int x=1; x<=n; x++ )
				{
				if( seen[x] == false )
					{
					if(DEBUG) System.out.println(COMMENT + " Warning: vertex "+x+" didn't appear in any edge : it will be considered a disconnected vertex on its own.");
					}
				}
				
				int vertices = n;
				
				int[][] matrix = new int[n+1][n+1]; // creating adjecency matrix based on the amount of vertices.
				for (int i = 0;i<e.length ;i++){
					
					int firstNumber =e[i].u; // the matrix is created based on the pairs from the graphs provided
					int secondNumber = e[i].v;
					
					matrix[firstNumber][secondNumber] = 1; 
					matrix[secondNumber][firstNumber] = 1;
				}
				int upperBound = upperBound(matrix);
				int lowerBound = lowerBound(matrix,upperBound);
				System.out.println("The upperbound is " + upperBound);
				System.out.println("the lower bound is " + lowerBound);
				int[] color;
				color = makeColorsArray(upperBound);
				
				int[] doneArray = new int[n]; //doneArray is the array that will contain the colorings of the nodes
                for (int j = 0;j <n; j++){
	                     if (j == 0 || j == 1){
		              doneArray[j] = 1;
	                       }
	              doneArray[j] = coloring(color,matrix,doneArray,j);
}
                        int chromaticNumber = findChromatic(doneArray);
                        System.out.println("The chromatic number is: " + chromaticNumber);
                        
                        for (int i=0; i<(n/2);i++){
                        int chromaticRandomized = randomizedTest(matrix,n,upperBound,color);
                        System.out.println("The chromatic number(randomized) is: " + chromaticRandomized);
                        }
                        
                        
				
				
				
				
				
					
		}
		
		private static int findChromatic(int[] array){
			int finalReturn=0;
                        for(int k=0;k<array.length;k++){
                        	if(array[k]>finalReturn){
                        		finalReturn=array[k];
                        	}
                        }
                        return finalReturn;
        }
			
		
		private static int upperBound(int[][] matrix) {
	int max = 0;
	int upperBound = 0;
	
	for(int i = 0; i < matrix[0].length; i++) { // based on Brooks Theorem, the upperbound can be at most the highest degree of edges +1
		for(int j = 0; j < matrix.length; j++) {
			if(matrix[i][j] == 1) {
				upperBound++;
			}
		}
		if(max < upperBound)
			max = upperBound;
			upperBound = 0;
	}
	return max + 1;
}

private static int[] makeColorsArray(int upperBound){ // the array doesnt contain 0 as its not counted towards amount of colors.
	int[] colors = new int[upperBound];
	for (int i = 1; i<colors.length+1;i++){
		colors[i-1]=i;
	}
	return colors;
}

private static int coloring(int[] colors,int[][] matrix,int[] done,int index){ 
	int[] array = Arrays.copyOf(colors,colors.length);
	for (int j = index-1;j>0;j--){
           if( matrix[index][j] == 1){
           	   int colorToRemove = done[j];
           	   for(int i=0; i<array.length; i++){
           	   	   if(array[i]==colorToRemove){
           	   	   	   array[i]=0;
           	   	   }
           }
           }
           }
           int lowestColor = findSmallest(array);
           return lowestColor;
           }
           
           private static int findSmallest(int[] copyArray){
           	   int smallestColor = 0;
           	   for(int i =0;i<copyArray.length;i++){
           	   	   if (copyArray[i] !=0){
           	   	   	   smallestColor = copyArray[i];
           	   	   	   break;
           	   	   }
           	   }
           	   return smallestColor;
           }
           
           /*
           randomizedTest method takes in 4 @params
           matrix = the adj. matrix
           vertices = number of vertices in the graph
           upperBound = the upperbound for the chromatic number, determined by Brooks Theorem
           color = an array of possible colors, its length is based on the upperbound
           
           Reason to use:
           the greedy coloring method has some inherent problems in some graph structures because it uses a specific order of vertices.
           But there might be a better solution when using a different order of the vertices checked.
           this method randomizes the order of vertices we check so we can see if theres a better solution.
           
           pseudocode:
           we create a list which has a length of the number of vertices,
           we randomize it using Collections.shuffle
           then we basically run the same method to actually color the 
          **/
           
           private static int randomizedTest(int[][] matrix,int vertices,int upperBound,int[] color){
           	   color[0] = 1;
           	   ArrayList<Integer> randomOrder = new ArrayList<Integer>(vertices+1);
           	   for (int i=1;i<vertices+1;i++){
           	   	   randomOrder.add(i);
           	   }
           	   Collections.shuffle(randomOrder);
           	   int[] doneArray = new int[vertices]; //doneArray is the array that will contain the colorings of the nodes
                for (int j = 0;j <vertices; j++){
                	int randomChoosing = randomOrder.get(j);
	                     if (j == 0){
		              doneArray[j] = 1;
	                       }else{
	                       //System.out.println(randomChoosing);
	                       
	              doneArray[j] = coloringRandom(color,matrix,doneArray,randomChoosing,randomOrder);
	              		   }
}
                        int chromaticNumber = findChromatic(doneArray);
                        return chromaticNumber;
           }
           
           private static int lowerBound(int[][] matrix,int upperBound) {
	int min = upperBound;
	int lowerbound = upperBound;
	int degrees = 0;
	
	for(int i = 0; i < matrix[0].length; i++) { // based on Brooks Theorem, the upperbound can be at most the highest degree of edges +1
		for(int j = 0; j < matrix.length; j++) {
			if(matrix[i][j] == 1) {
				degrees++;
			}
		}
		if(lowerbound > degrees && degrees<min && degrees > 1 ){
			min = degrees;
			degrees = 0;
	}
	degrees = 0;
}
return min;
		   }
		   // same as the coloring method, just takes on extra @param which is randomOrder- the order of the vertices checked.
		   private static int coloringRandom(int[] colors,int[][] matrix,int[] done,int index,ArrayList<Integer> randomOrder){ 
	int[] array = Arrays.copyOf(colors,colors.length);
	int test = randomOrder.indexOf(index);
	for (int j = test-1;j>0;j--){
           if( matrix[index][randomOrder.get(j)] == 1){
           	   //System.out.println("the color we remove is : " + done[j]);
           	   int colorToRemove = done[j];
           	   for(int i=0; i<array.length; i++){
           	   	   if(array[i]==colorToRemove){
           	   	   	   array[i]=0;
           	   	   }
           }
           }
           }
         //  for (int i = 0;i<array.length;i++){
           //	   System.out.print(array[i]);
           	 //  System.out.println();
           //}
           int lowestColor = findSmallest(array);
           return lowestColor;
           }
           
           	   

}
